extends base

- load widget_tweaks
- load comments
- load group


block header
  - with headerMessage=group.name
    include includes/header


block content
  .container-fluid
    .row
      #chart(style="height:800px;").col-xs-10.col-xs-offset-1

    .row
      .col-xs-6

        #control-pane
          h2.underline filters

          div
            h3 min degree <span id="min-degree-val">0</span>
            input(id="min-degree", type="range", min="0", max="0", value="0")

          div
            button#reset-btn Reset filters



block post-footer
  script.

    var s = new sigma({
      container: 'chart',
      settings: {

        defaultLabelColor: "#000",
        defaultLabelSize: 14,
        defaultLabelBGColor: "#ddd",
        defaultHoverLabelBGColor: "#002147",
        defaultLabelHoverColor: "#fff",

        edgeColor: 'default',
        defaultEdgeColor: '#ccc',

        labelThreshold: 10,
        defaultEdgeType: "curvedArrow",

        hoverFontStyle: "bold",
        fontStyle: "bold",
        activeFontStyle: "bold",

        minNodeSize: 1,
        maxNodeSize: 7,
        minEdgeSize: 0.1,
        maxEdgeSize: 0.5,

        minRatio: 0.75,
        maxRatio: 20,
      }
    });
    var filter = new sigma.plugins.filter(s);

    function updatePane (graph, filter) {
      var maxDegree = 0;
      graph.nodes().forEach(function(n) {
        maxDegree = Math.max(maxDegree, graph.degree(n.id));
      });
      console.log(maxDegree);
    };

    console.log('[SIGMA LOG] Loading...');
    sigma.parsers.json('/api/network/{{group.pk}}/', s, function() {
      console.log('[SIGMA LOG] Loaded');
      s.refresh();
    });
    s.refresh();

    updatePane(s.graph, filter);
    function applyMinDegreeFilter(num) {
      console.log(num);
      $('min-degree-val').textContent = num;

      filter
        .undo('min-degree')
        .nodesBy(function(n) {
          return this.degree(n.id) >= num;
        }, 'min-degree').apply();
    };

    function applyUserFilter(username) {
      console.log(username);
      filter
        .undo('edge-contributor')
        .edgesBy(function(edge) {
          return edge.attributes.user == username;
        }, 'edge-contributor').apply();
    };


    /*
    var dragListener = sigma.plugins.dragNodes(s, s.renderers[0]);
    dragListener.bind('startdrag', function(event) {
      console.log(event);
    });

    dragListener.bind('drag', function(event) {
      console.log(event);
    });

    dragListener.bind('drop', function(event) {
      console.log(event);
    });

    dragListener.bind('dragend', function(event) {
      console.log(event);
    });
    */

    /*
    sigInst.bind('overnodes',function(event){
      var nodes = event.content;
      var neighbors = {};

      sigInst.iterEdges(function(e){
        if(nodes.indexOf(e.source)<0 && nodes.indexOf(e.target)<0){
          if(!e.attr['grey']){
            e.attr['true_color'] = e.color;
            e.color = greyColor;
            e.attr['grey'] = 1;
          }
        } else {
          e.color = e.attr['grey'] ? e.attr['true_color'] : e.color;
          e.attr['grey'] = 0;

          neighbors[e.source] = 1;
          neighbors[e.target] = 1;
        }
      }).iterNodes(function(n){
        if(!neighbors[n.id]){
          if(!n.attr['grey']){
            n.attr['true_color'] = n.color;
            n.color = greyColor;
            n.attr['grey'] = 1;
          }
        } else {
          n.color = n.attr['grey'] ? n.attr['true_color'] : n.color;
          n.attr['grey'] = 0;
        }
      }).draw(2,2,2);

    }).bind('outnodes',function(){
      sigInst.iterEdges(function(e){
        e.color = e.attr['grey'] ? e.attr['true_color'] : e.color;
        e.attr['grey'] = 0;
      }).iterNodes(function(n){
        n.color = n.attr['grey'] ? n.attr['true_color'] : n.color;
        n.attr['grey'] = 0;
      }).draw(2,2,2);
    });

    sigInst.draw();
    */
